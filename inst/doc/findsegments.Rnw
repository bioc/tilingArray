%\VignetteIndexEntry{How to use the findsegments function to fit a piecewise constant curve}
%\VignetteDepends{Biobase}
%\VignetteKeywords{Expression Analysis}
%\VignettePackage{tilingArray}

\documentclass[11pt]{article}
\usepackage{color}
\definecolor{darkblue}{rgb}{0.0,0.0,0.75}
\usepackage[%
baseurl={http://www.bioconductor.org},%
pdftitle={How to use the findsegments function to fit a piecewise constant curve},%
pdfauthor={Wolfgang Huber},%
pdfsubject={tilingArray},%
pdfkeywords={Bioconductor},%
pagebackref,bookmarks,colorlinks,linkcolor=darkblue,citecolor=darkblue,%
pagecolor=darkblue,raiselinks,plainpages,pdftex]{hyperref}

\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}

\newcommand{\myincfig}[3]{%
  \begin{figure}[htbp]
    \begin{center}
      \includegraphics[width=#2]{#1}
      \caption{\label{#1}#3}
    \end{center}
  \end{figure}
}

\begin{document}

%------------------------------------------------------------
\title{How to use the findsegments function to fit a piecewise constant curve}
%------------------------------------------------------------
\author{Wolfgang Huber}
\maketitle
% \tableofcontents

%--------------------------------------------------
\section{Introduction}
%--------------------------------------------------

The problem of segmenting a series of numbers into piecewise constant segments
occurs in multiple application areas. Two examples are
\begin{itemize}
\item arrayCGH data, where the segments correspond to regions of copy number
  gain, loss, or no change.
\item tiling microarray data for transcriptomics, where the segments
  correspond to transcripts. Here we assume that the probe effects (which lead
  to different fluorescence intensities even for the same mRNA abundance) have
  been normalized away, so that all probes for one transcript
  have the same fluorescence (in expectation).
\end{itemize}

To demonstrate and verify the correctness of the algorithm, let's generate
simulated data:
%
<<defGenData>>=
genData = function(lenx, nrcp, stddev=0.1) {
  x  = numeric(lenx)
  cp = c(1, sort(sample(1:floor(lenx/15), nrcp-1) * 15), lenx+1)
  s  = 0
  for (j in 2:length(cp)) {
    sel = cp[j-1]:(cp[j]-1)
    s = (.5+runif(1))*sign(rnorm(1))+s
    x[sel] <- rnorm(length(sel), mean=s, sd=stddev)
  }
  return(list(x=x, cp=cp[-1]))
}
@ 
<<plotData,fig=TRUE,include=FALSE>>=
lenx = 1000
nrcp = 10
gd = genData(lenx, nrcp)
plot(gd$x, pch=".")
abline(v=gd$cp, col="red")
@ 
%
\myincfig{findsegments-plotData}{0.6\textwidth}{%
A simulated data example with \Sexpr{nrcp} change points, shown with red
vertical lines}
%
The result is shown in Figure~\ref{findsegments-plotData}.
We can use the function \Rfunction{findsegments} to reconstruct the
changepoints from the \Robject{x} data alone.
%
<<loadlib, results=hide>>=
library(tilingArray)
@ 
<<findSegments>>=
library(tilingArray)
maxk = 500
maxcp   = 12
seg  = findsegments(gd$x, maxk=maxk, maxcp=maxcp)
seg
gd$cp
@ 
%
We see that the \Sexpr{nrcp}-th row of the matrix \Robject{seg\$th} 
exactly reconstructs the change points \Robject{gd\$cp} that were 
used in the simulation.

The parameters \Robject{maxcp} and \Robject{maxk} are the maximum number of
segments and the maximum length per segment. The algorithm finds for each
value of $k$ from \Robject{1} to \Robject{maxcp} the best segmentation under
the restriction that no individual segment be longer than \Robject{maxk}.  In
the original paper of Picard et al.~\cite{Picard} and in their software,
\Robject{maxk} is implicitely set to the number of data points
\Robject{length(x)}. I have introduced this parameter to reduce the
algorithm's complexity. The complexity of Picard's software is
\Robject{length(x)*length(x)} in memory and
\Robject{length(x)*length(x)*maxcp} in time,
the complexity of the \Rfunction{findsegments} function is 
\Robject{length(x)*maxk} in memory and
\Robject{length(x)*maxk*maxcp} in time. As I am
envisaging applications with \Robject{length(x)} $\approx 10^5$ and
\Robject{maxk} $\approx 250$, the difference can be substantial.

%--------------------------------------------------
\section{How to choose the number of segments?}
%--------------------------------------------------
Need to assess goodness of fit (contained in \Robject{gd\$J}) together with 
model complexity (i.\,e.\, the number of change points). Details will follow $\ldots$

%--------------------------------------------------
\section{Some more testing}
%--------------------------------------------------
Here is a little for-loop that generates data using random parameters 
and checks whether \Rfunction{findsegments} can reconstruct them. 
The purpose of this is for checking the validity of the code. 
<<testing>>=
set.seed(4711)
for(i in 1:20){
  gd  = genData(lenx, nrcp)
  seg = findsegments(gd$x, maxk=maxk, maxcp=maxcp)
  stopifnot(seg$th[nrcp, 1:nrcp] == gd$cp)
}
@ 

%--------------------------------------------------
\begin{thebibliography}{10}
%--------------------------------------------------

\bibitem{Picard}
A statistical approach for CGH microarray data analysis.
\newblock Franck Picard, Stephane Robin, Marc Lavielle, Christian Vaisse,
  Gilles Celeux, Jean-Jacques Daudin.
\newblock Rapport de recherche No. 5139, Mars 2004,
  \textit{Institut National de Recherche en Informatique et en Automatique (INRIA)},
  ISSN 0249-6399.
  \url{http://www.inapg.fr/ens_rech/mathinfo/recherche/mathematique/outil.html}

\end{thebibliography}
\end{document}


