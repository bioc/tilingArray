%\VignetteIndexEntry{tilingArray - demo segmentation}
%\VignetteDepends{tilingArray}
%\VignetteKeywords{segmentation}
%\VignettePackage{tilingArray}

\documentclass[11pt]{article}
\usepackage{geometry}\usepackage{color}
\definecolor{darkblue}{rgb}{0.0,0.0,0.75}
\usepackage[%
baseurl={http://www.bioconductor.org},%
pdftitle={Segmentation demo},%
pdfauthor={Wolfgang Huber},%
pdfsubject={tilingArray},%
pdfkeywords={Bioconductor},%
pagebackref,bookmarks,colorlinks,linkcolor=darkblue,citecolor=darkblue,%
pagecolor=darkblue,raiselinks,plainpages,pdftex]{hyperref}

%------------------------------------------------------------
% newcommand
%------------------------------------------------------------
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}
\newcommand{\mbs}[1]{{\mbox{\scriptsize #1}}}

\newcommand{\myincfig}[3]{%
  \begin{figure}[htbp]
    \begin{center}
      \includegraphics[width=#2]{#1}
      \caption{\label{#1}#3}
    \end{center}
  \end{figure}
}

\begin{document}

%------------------------------------------------------------
\title{Segmentation demo}
%------------------------------------------------------------
\author{Wolfgang Huber}
\maketitle
\tableofcontents

\section{Introduction}
This script presents a demo of the segmentation function
on the \Rpackage{davidTiling} data. 

First we load the package \Rpackage{tilingArray}, which contains the
algorithms, and the package \Rpackage{davidTiling}, which contains the
data and the array annotation.

<<setup, results=hide>>=
##options(error=recover, warn=0)
##graphics.off()

library("tilingArray")
library("davidTiling")
data("davidTiling")
data("probeAnno")
@ 

%--------------------------------------------------
\section{Normalization of the data}
%--------------------------------------------------
Please see the vignette \textit{Assessing signal/noise ratio before
and after normalization} (\texttt{assessNorm.Rnw}) for an explanation 
of the following code.
%
<<normalization>>=
nc = as.integer(2560)
PMind = rep(seq(as.integer(1), nc-as.integer(3), by=as.integer(2)), each=nc)*nc + (1:nc)
MMind = PMind + nc

ispm = rep(FALSE, nc*nc)
ispm[PMind] = TRUE
isbg = (probeAnno$probeReverse$no_feature=="no" &
        probeAnno$probeDirect$no_feature=="no" &
        ispm)
isRNA = davidTiling$nucleicAcid %in% c("poly(A) RNA","total RNA")
isDNA = davidTiling$nucleicAcid %in% "genomic DNA"
stopifnot(sum(isRNA)==5, sum(isDNA)==3)
xn = normalizeByReference(davidTiling[,isRNA], davidTiling[,isDNA], 
  pm=PMind, background=isbg)
pData(xn)[, 2, drop=FALSE]
@ 


%--------------------------------------------------
\section{Segmentation}
%--------------------------------------------------

\subsection{Selecting the probes in along-chromosome order}
Extract for all probes that map to the "+" strand of chromosome 1  their
start and end coordinate, and their index in the exprs(davidTiling)
data matrix.  Sort them by midpoint.

<<prbs>>=
chrstrd = "1.+"
what = c("start", "end", "index", "unique")
prbs = do.call("data.frame", mget(paste(chrstrd, what, sep="."), probeAnno))
colnames(prbs) = what
prbs$mid = (prbs$start+prbs$end)/2
prbs = prbs[order(prbs$mid), ]
@ 

Throw out the missing (\Robject{NA}) values.
<<throwOutNA>>=
numna = rowSums(is.na(exprs(xn)[ prbs$ind, ]))
stopifnot(all(numna %in% c(0, ncol(xn))))
prbs = prbs[numna==0,]
@ 

%--------------------------------------------------
\subsubsection{Avoid oversampling}
Figure~\ref{segmentation-histprobs} shows that the spacing between the
probes is not completely regular, in particular, repetitive regions
are highly oversampled. We subsample the probes, the result of this is
shown in the comparison between Figures~\ref{segmentation-histprobs}b
and \ref{segmentation-histprobs}c.
%
<<sampleStep>>=
sprb = prbs[ sampleStep(prbs$mid, step=7), ]
@ 
%
<<histprobs, fig=TRUE, include=FALSE, width=6, height=7>>=
par(mfrow=c(3,1))
hist(prbs$mid, col="mistyrose", 100, main="(a)")
barplot(table(diff(prbs$mid)), main="(b)")
barplot(table(diff(sprb$mid)), main="(c)")
@ 
%
\myincfig{segmentation-histprobs}{0.7\textwidth}{% 
(a):
Histogram of probe midpoints along the ``+'' strand of chromosome 1.  There are some
probe dense regions in particular around 160,000.  The sequence of
that region is repeated multiple times in the genome, and due to the way 
the chip was designed, there are also a lot of probes (more than necessary) for that region.
(b): histogram of differences between probe midpoints (\Robject{prbs\$mid}).
The intention of the chip design was to have a regular spacing of 8 bases.
In some cases, the spacing is wider, probably due to updates in the 
genome sequence between when the chip was designed and 
when probes were re-aligned. In  many cases, it is tighter with multiple 
probes for the same target sequence, or only 1 or 2 bases offset. This occurs 
in the regions of duplicated sequence.
(c): histogram of differences between probe midpoints after sampling
(\Robject{sprb\$mid})
}

%--------------------------------------------------
\subsection{Call the segmentation algorithm}
The segmentation algorithm needs two parameters, \Robject{maxseg}, the
maximum number of segments that the algorithm is going to consider,
and \Robject{maxk}, the maximum length of individual segments. We
choose \Robject{maxseg} to be quite high, such that it corresponds to
an \emph{average} length per segment of 750 bases.  The algorithm will
calculate all optimal segmentations with $1, 2, \ldots,$
\Robject{maxseg} segments, and we can still later choose our prefered
one.  Note that \Robject{maxk} is measured in number of data points,
not in genomic coordinates.  Our choice of the parameter
\Robject{maxk} corresponds to a maximum segment length of about $7.5
\times 3,000 = 22,500$ bases. Note that there is no minimum length
restriction for the segments.
%
<<maxseg, print=TRUE>>=
maxseg = round(sprb$end[nrow(sprb)]/750)
@ 
%
<<segmentShow, eval=FALSE>>=
y = exprs(xn)[sprb$ind, xn$nucleicAcid=="poly(A) RNA", drop=FALSE]
segw = segment(y, maxseg=maxseg, maxk=3000)
@ 
<<segmentDo, echo=FALSE, results=hide>>=
y = exprs(xn)[sprb$ind, xn$nucleicAcid=="poly(A) RNA", drop=FALSE]
cache(segw <- segment(y, maxseg=maxseg, maxk=3000))
@ 
%
We also add additional information to the object that was not used for
the actual segmentation, but will be useful for the visualization:
into the slot \Robject{x}, the $x$-coordinates of the probes, 
and into the slot \Robject{flag}, the uniqueness status of the probes 
(0 iff the probe has exactly one match in the genome):
%
<<addMidUnique>>=
segw@x = sprb$mid
segw@flag = sprb$unique
@
% 
Having to access the \Robject{x} and \Robject{flag} slots directly, 
as in the code above, is a bit unelegant. I intend to provide accessor
functions in subsequent versions of the package.

%--------------------------------------------------
\subsection{Calculate confidence intervals}
This is simply a call to the \Rfunction{confint} method of the 
\Rclass{segmentation} class.
%
<<confint>>=
nseg = round(sprb$end[nrow(sprb)]/1500)
confintLevel = 0.95
segwi = confint(segw, parm=nseg, level=confintLevel)
@ 
%
Now we are ready to have a look at the result via the \Rfunction{plot} method
of the \Rclass{segmentation} class. The plot is shown in Figure~\ref{segmentation-plotseg}.
%
<<plotseg, fig=TRUE, include=FALSE, width=8, height=4, eps=FALSE>>=
plot(segwi, nseg, pch=".", xlim=c(0, 40000))
@ 
\myincfig{segmentation-plotseg}{\textwidth}{% 
Segmentation with confidence intervals.
}

%--------------------------------------------------
\subsection{Model selection.}
%--------------------------------------------------
The log-likelihood is
\begin{equation}
\log L = -\frac{n}{2}\left(\log 2\pi +1 +\log\frac{\sum_i r_i}{n}\right),
\end{equation}
where $r_i$ the $i$-th residual and $n$ the number of data points.
AIC and BIC are defined as
\begin{eqnarray}
\mbox{AIC}&=& -2\log L + 2p\\
\mbox{BIC}&=& -2\log L + p\log n
\end{eqnarray}
where $p$ is the number of parameters of the model. In our case,
$p=2S$, since for a segmentation with $S$ segments, we estimate $S-1$
changepoints, $S$ mean values, and 1 standard deviation. We can
also consider the penalized likelihoods
\begin{eqnarray}
\log L_{\mbs{AIC}}&=& \log L - p\\
\log L_{\mbs{BIC}}&=& \log L -\frac{p}{2}\log n
\end{eqnarray}
%
We plot them as functions of $S$, see Figure~\ref{segmentation-modelSelect}
%
<<modelSelect, fig=TRUE, eps=FALSE, include=FALSE, width=5, height=5>>=
par(mai=c(1,1,0.1,0.01))
tilingArray:::plotPenLL(segwi, extrabar=c("black"=round(segwi@x[length(segwi@x)]/1500))) 
@ 
%
\myincfig{segmentation-modelSelect}{0.5\textwidth}{% 
Model selection: log-likelihood and two versions of penalized
log-likelihood (AIC and BIC) as a function of the number of segments
$S$. Vertical dashed green bar corresponds to optimal $\log L_{\mbs{BIC}}$,
vertical dashed grey bar to our ``subjective'' choice of average segment
length 1,500 bases.}

%--------------------------------------------------
\subsection{Size of the confidence intervals as a function of $S$}
%--------------------------------------------------
<<confintwidthscalc>>=
segwj = confint(segw, parm=as.integer(c(112, 153, 194, 235, 276)),
  level=confintLevel) 

nBp = which(segwj@hasConfint)
confintwidths = lapply(segwj@breakpoints[nBp], function(m) (m[,3]-m[,1]))
@ 
<<confintwidthsecdf, fig=TRUE, eps=FALSE, include=FALSE, width=5, height=5>>=
maxx = 20
colors = brewer.pal(length(nBp), "Set1")
multiecdf(confintwidths, xlim=c(0, maxx), 
  main='distribution of lengths of confidence intervals', verticals=TRUE, lwd=2, col=colors)
legend(x=0.6*maxx, y=0.5, legend=paste("S =", nBp), col=colors, lty=1, lwd=2) 
@ 
\myincfig{segmentation-confintwidthsecdf}{0.5\textwidth}{% 
Size of the confidence intervals as a function of $S$.
Cumulative distribution functions (CDFs) for the distributions of confidence 
interval widths for $S=$\Sexpr{paste(nBp, collapse=", ")}. 
For larger $S$, the confidence intervals are wider.}

%--------------------------------------------------
\subsection{Definition of segFun}

For the subsequent considerations, it will be useful to define the
function \Rfunction{segFun}.  It encapsulates the complete set of
segmentation computations, as shown above, for one chromosome strand.  Its result
is a \Rclass{segmentation} object with confidence intervals.
%
<<segFun, results=hide>>=
segFun = function(chrstrd, nrBasesPerSegment=1500) {
  writeLines(sprintf("Working on %s", chrstrd), con="segmentation.log")

  what = c("start", "end", "index", "unique")
  prbs = do.call("data.frame", mget(paste(chrstrd, what, sep="."), probeAnno))
  colnames(prbs) = what
  prbs$mid = (prbs$start+prbs$end)/2
  prbs = prbs[order(prbs$mid), ]

  numna = rowSums(is.na(exprs(xn)[ prbs$ind, ]))
  stopifnot(all(numna %in% c(0, ncol(xn))))
  prbs = prbs[numna==0,]

  sprb = prbs[ sampleStep(prbs$mid, step=7), ]
  nseg = round(sprb$end[nrow(sprb)]/nrBasesPerSegment)

  y = exprs(xn)[sprb$ind, xn$nucleicAcid=="poly(A) RNA", drop=FALSE]
  s = segment(y, maxseg=nseg, maxk=3000)
  s@x = sprb$mid
  s@flag = sprb$unique

  confint(s, parm=nseg, level=confintLevel) }
@
%--------------------------------------------------
\subsection{Using the \Rfunction{plotAlongChrom} function for more elaborate displays.}

Since the data in the \Rpackage{davidTiling} package are
strand-specific, we can do the segmentation for the ``-'' strand as
well and produce the along-chromosome plot shown in
Figure~\ref{segmentation-fig1}. 

For Figure~\ref{segmentation-fig1}, we call \Rfunction{segFun} on the
``-'' strand of chromosome 1.  For Figures~\ref{segmentation-fig2-pnas} 
and \ref{segmentation-fig2-bioinf}, we
also call it on a number of other chromosomes. 

This computation will
take a couple of hours (about 18h on mine). Note that the
\Robject{for}--loop below can be trivially parallelized since the
computations for different chromosome strands are independent of each
other. A simple synchronization mechanism through creation of a 
\emph{lock file} is already provided in the code example below.
%
<<computeSegmentations>>=
toDo = c("1.-", "2.+", "2.-", "5.+", "5.-", "9.+", "9.-", "13.+", "13.-", 
  "14.+", "14.-","15.+", "15.-")
for(w in toDo) {
  fn = paste(w, "rda", sep=".")
  if(!file.exists(fn)) {
    writeLines(date(), con=fn) ## lock
    assign(w, segFun(w))
    save(list=w, file=fn, compress=TRUE)
  }
}
@ 
%
Finally, we collect all results in the environment \Robject{segObj}.
%
<<makeSegObj>>=
segObj = new.env(parent = baseenv())
assign("1.+", segwi, segObj)
for(w in toDo) {
  load(paste(w, "rda", sep="."))
  assign(w, get(w), segObj)
}

data("gff")
myGff = gff[ gff$Name!="tR(UCU)E", ]
ylim  = quantile(exprs(xn)[,1:3], probs=c(0.001, 0.999), na.rm=TRUE)
@ 

The function \Rfunction{plotAlongChrom} accepts an environment as its
first argument, which is expected to contain objects of class
\Rclass{segmentation} with names given by 
\Robject{paste(chr, c("+", "-"), sep=".")}, where \Robject{chr} is the
chromosome identifier.
%
\myincfig{segmentation-fig1}{\textwidth}{% 
Along-chromosome plot similar to Figure 1 in~\cite{David2006}.}
\myincfig{segmentation-fig2-pnas}{\textwidth}{% 
Along-chromosome plots similar to Figure 2 in~\cite{David2006}.}
\myincfig{segmentation-fig2-bioinf}{\textwidth}{% 
Along-chromosome plots similar to Figure 2 in~\cite{Huber2006}.}
%
In the following, the code to generate Figure 1 in~\cite{David2006}.
%
<<fig1, fig=TRUE, eps=FALSE, include=FALSE, width=16, height=6>>=
grid.newpage()
plotAlongChrom(segObj=segObj, chr=1, coord = c(30, 130)*1e3, ylim=ylim, 
               gff=myGff, showConfidenceIntervals=FALSE,
               featureNoLabel = c("uORF", "binding_site", "TF_binding_site"),
               doLegend=FALSE, main="")  
@ 
%
In the following, the code to generate Figure 2 in~\cite{David2006}.
%
<<fig2-pnas, fig=TRUE, eps=FALSE, include=FALSE, width=11, height=5.5>>=
myPlot = function(row, col, ...) {
  pushViewport(viewport(layout.pos.row=row, layout.pos.col=col))
  grid.rect(x=-0.1, width=1.15, y=0.0, height=1.02, just=c("left", "bottom"),
            default.units="npc", gp=gpar(lwd=0.2))
  plotAlongChrom(..., segObj=segObj, ylim=ylim,  
                 ## probeAnno = probeAnno, 
                 gff=myGff,
                 featureNoLabel = c("uORF", "binding_site", "TF_binding_site"),
                 doLegend=FALSE)  
  popViewport()
}
myLegend = function(row, col, what) {
  fc = tilingArray:::featureColors(1)
  fc = switch(what,
    fc[c("CDS", "CDS_dubious", "uORF", "ncRNA", "TF_binding_site"), ],
    fc[c("CDS", "CDS_dubious", "TF_binding_site"), ])

  pc = c("Watson strand probe"="#00441b", "Crick strand probe"="#081d58", "Non-unique probe"="grey")
  sc = c("Segment boundary"="#777777")

  pushViewport(dataViewport(xscale=c(0,1), yscale=c(-7,nrow(fc)+1), layout.pos.col=col, layout.pos.row=row))
  h1  = nrow(fc):1
  h2  = 0:(1-length(pc))
  h3  = -length(pc)
  
  w   = 0.2
  grid.rect(x=0, width=w, y=h1, height = unit(1, "native")- unit(2, "mm"), 
            just  = c("left", "center"), default.units="native",
            gp    = do.call("gpar", fc))
  grid.circle(x = w/2, y=h2, r=0.2, default.units="native",
              gp = gpar(col=pc, fill=pc))
  grid.lines(x=w/2, y=h3+c(-.3,+.3), default.units="native", gp=gpar(col=sc))
  grid.text(label = c(gsub("_", " ", rownames(fc)), names(pc), names(sc)), x = w*1.1, y = c(h1,h2,h3),
            just  = c("left", "center"), default.units="native",
            gp=gpar(cex=.7))
  popViewport()
}
  
dx = 0.20
dy = 0.05
grid.newpage()
pushViewport(viewport(x=0.02, width=0.96, height=0.96, just=c("left", "center"),
                      layout=grid.layout(3, 8,
                        height=c(1, dy, 1),
                        width =c(dx, 1, dx, 1, dx, 1, dx, 1))))
         
## A) 13:550k splicing RPS16A, RPL13B
myPlot(1, 2, chr=13, coord = c(550044, 553360), main="a")
## B) GCN4
myPlot(1, 4, chr=5, coord = c(138660, 141880), main="b")
## C) MET7, novel architecture
myPlot(1, 6, chr=15, coord = c(784700, 790000), main="c")
## D) overlapping transcripts
myPlot(1, 8, chr=14, coord = c(342200, 347545), main="d")
## E) SER3
myPlot(3, 2, chr=5, coord = c(321900, 326100), main="e")
## F) 2:360.5-366.5: novel isolated
myPlot(3, 4, chr=2, coord = c(360500, 365970), main="f")
## G) 9:221-227: novel antisense SPO22
myPlot(3, 6, chr=9, coord = c(221000, 226500), main="g")

myLegend(3, 8, 1)
popViewport()
@ 
%
In the following, the code to generate Figure 2 in~\cite{Huber2006}.
%
% aspect ratio: 4.3.  11/4.3 = 2.55
%
<<fig2-bioinf, fig=TRUE, eps=FALSE, include=FALSE, width=11, height=2.75>>=
grid.newpage()
pushViewport(viewport(x=0.02, width=0.96, height=0.96, just=c("left", "center"),
                      layout=grid.layout(1, 8,
                        height=c(1),
                        width =c(0.05, 1, 0.15, 1, 0.15, 1, 0.15, 0.5))))
         
## 13:550k splicing RPS16A, RPL13B
myPlot(1, 2, chr=13, coord = c(550044, 553360), main="a")
## MET7, novel architecture
myPlot(1, 4, chr=15, coord = c(784700, 790000), main="b")
## 9:221-227: novel antisense SPO22
myPlot(1, 6, chr=9, coord = c(221000, 226500), main="c")

myLegend(1, 8, 2)
popViewport()
@ 

\begin{thebibliography}{10}

\bibitem{David2006}
Lior David, Wolfgang Huber, Marina Granovskaia, Joern Toedling, Curtis J. Palm, Lee Bofkin, Ted Jones,
Ronald W. Davis, and Lars M. Steinmetz
\newblock A high-resolution map of transcription in the
yeast genome.
\newblock \textit{PNAS}, 2006.

\bibitem{Huber2006}
Wolfgang Huber, Joern Toedling and Lars M. Steinmetz
\newblock Transcript mapping with oligonucleotide high-density tiling arrays.
\newblock \textit{Bioinformatics}, 2006.

\end{thebibliography}
\end{document}





          
