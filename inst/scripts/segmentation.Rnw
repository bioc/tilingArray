%\VignetteIndexEntry{tilingArray - demo segmentation}
%\VignetteDepends{tilingArray}
%\VignetteKeywords{segmentation}
%\VignettePackage{tilingArray}

\documentclass[11pt]{article}
\usepackage{geometry}\usepackage{color}
\definecolor{darkblue}{rgb}{0.0,0.0,0.75}
\usepackage[%
baseurl={http://www.bioconductor.org},%
pdftitle={Segmentation demo},%
pdfauthor={Wolfgang Huber},%
pdfsubject={tilingArray},%
pdfkeywords={Bioconductor},%
pagebackref,bookmarks,colorlinks,linkcolor=darkblue,citecolor=darkblue,%
pagecolor=darkblue,raiselinks,plainpages,pdftex]{hyperref}

%------------------------------------------------------------
% newcommand
%------------------------------------------------------------
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}

\newcommand{\myincfig}[3]{%
  \begin{figure}[htbp]
    \begin{center}
      \includegraphics[width=#2]{#1}
      \caption{\label{#1}#3}
    \end{center}
  \end{figure}
}

\begin{document}

%------------------------------------------------------------
\title{Segmentation demo}
%------------------------------------------------------------
\author{Wolfgang Huber}
\maketitle
\tableofcontents

\section{Introduction}
This script presents a demo of the segmentation function
on the \Rpackage{davidTiling} data.

<<setup, results=hide>>=
options(error=recover, warn=0)
graphics.off()

library("tilingArray")
library("davidTiling")
if(!exists("davidTiling"))
  data("davidTiling")
if(!exists("probeAnno"))
  data("probeAnno")
@ 
<<sourceStuff>>=
## source("setScriptsDir.R")
## source(functionsDir("plotAlongChrom.R"))
@ 


%--------------------------------------------------
\section{Normalization}
%--------------------------------------------------
Please see the vignette \textit{Assessing signal/noise ratio before
and after normalization} (\texttt{assessNorm.Rnw}) for explanation.
<<normalization>>=
xn = cache("xn", {
  nc = as.integer(2560)
  PMind = rep(seq(as.integer(1), nc-as.integer(3), by=as.integer(2)), each=nc)*nc + (1:nc)
  MMind = PMind + nc

  ispm = rep(FALSE, nc*nc)
  ispm[PMind] = TRUE
  isbg = (probeAnno$probeReverse$no_feature=="no" &
          probeAnno$probeDirect$no_feature=="no" &
          ispm)
  isRNA = davidTiling$nucleicAcid %in% c("poly(A) RNA","total RNA")
  isDNA = davidTiling$nucleicAcid %in% "genomic DNA"
  stopifnot(sum(isRNA)==5, sum(isDNA)==3)
  normalizeByReference(davidTiling[,isRNA], davidTiling[,isDNA], 
                       pm=PMind, background=isbg)
})
pData(xn)[, 2, drop=FALSE]
@ 


%--------------------------------------------------
\section{Segmentation}
%--------------------------------------------------

\subsection{Selecting the probes in along-chromosome order}
Extract for all probes that map to the "+" strand of chromosome 1  their
start and end coordinate, and their index in the exprs(davidTiling)
data matrix.  Sort them by midpoint.

<<prbs>>=
chrstrd = "1.+"
what = c("start", "end", "index")
prbs = do.call("data.frame",
  mget(paste(chrstrd, what, sep="."), probeAnno))
colnames(prbs) = what
prbs$mid = (prbs$start+prbs$end)/2
prbs = prbs[order(prbs$mid), ]
@ 

We throw out the missing (\Robject{NA}) values:
<<throwOutNA>>=
numna = rowSums(is.na(exprs(xn)[ prbs$ind, ]))
stopifnot(all(numna %in% c(0, ncol(xn))))
prbs = prbs[numna==0,]
@ 

%--------------------------------------------------
\subsubsection{Avoid oversampling}
<<sampleStep>>=
sprb = prbs[ sampleStep(prbs$mid, step=7), ]
@ 

<<histprobs, fig=TRUE, include=FALSE, width=6, height=7>>=
par(mfrow=c(3,1))
hist(prbs$mid, col="mistyrose", 100, main="(a)")
barplot(table(diff(prbs$mid)), main="(b)")
barplot(table(diff(sprb$mid)), main="(c)")
@ 
%
\myincfig{segmentation-histprobs}{0.7\textwidth}{% 
(a):
Histogram of probe midpoints along the chromosome.  There are some
probe dense regions in particular around 160,000.  The sequence of
that region is repeated multiple times in the genome, and due to the
chip design, there are also a lot of probes (more than necessary) for that region.
(b): histogram of differences between probe midpoints (\Robject{prbs\$mid}).
The intention of the chip design was to have a regular spacing of 8 bases.
In some cases, the spacing is wider, probably due to updates in the 
genome sequence between when the chip was designed and 
when probes were re-aligned. In  many cases, it is tighter with multiple 
probes for the same target sequence, or only 1 or 2 bases offset. This occurs 
in the regions of duplicated sequence.
(c): histogram of differences between probe midpoints after sampling
(\Robject{sprb\$mid})
}

%--------------------------------------------------
\subsection{Call the segmentation algorithm}
The segmentation algorithm needs two parameters, 
\Robject{maxseg}, the maximum number of segments
that the algorithm is going to consider, and \Robject{maxk}, the
maximum length per segment (in data points) of individual segments.
The algorithm will calculate all optimal segmentations with $1, 2,
\ldots, \mbox{maxseg}$ segments. The choice that we make here corresponds
to an \emph{average} length per segment of 1500 bases.
Our choice of the parameter \Robject{maxk} corresponds to a maximum 
segment length of about $7.5 \times 3,000 = 22,500$ bases.
<<maxseg, print=TRUE>>=
maxseg = round(sprb$end[nrow(sprb)]/1500)
@ 
%
<<segment>>=
seg = cache("seg", {
  y = exprs(xn)[sprb$ind, xn$nucleicAcid=="poly(A) RNA", drop=FALSE]
  seg = segment(y, maxseg=maxseg, maxk=3000)
})
@ 

%--------------------------------------------------
\subsection{Calculate confidence intervals}

<<confint>>=
segc = cache("segc",
  confint(seg, parm=maxseg)
)
@ 



<<eval=FALSE, echo=FALSE>>=
what = c("dotsSeg", "dotsUnseg", "heatmap")[1]
name = sprintf("fig_tiling_%s", what)


  for(dev in c("png", "pdf")) {
    switch(dev,
           X11 = {
             X11(width=15, height=8)
             grid.newpage()
           },
           pdf = pdf(file=sprintf("%s.pdf", name), width=8, height=4.7),
           png = png(file=sprintf("%s.png", name), width=1024, height=768),
           stop("Sapperlot"))
    
    
    ## dots plot with segmentation
    if(what=="dotsSeg") {
      rnaTypes = rt = "seg-polyA-050909"
      source(scriptsDir("readSegments.R"))
      source(scriptsDir("calcThreshold.R"))
      plotAlongChrom(chr=1, coord = 1000*c(76.2, 92.8),
                     segObj = get(rt),
                     gff = gff)
    }
    
    ## dots plot without segmentation, just normalized intensities
    if(what=="dotsUnseg"){
      ## if(!exists("a"))load("a.rda")
      if(!exists("probeAnno"))load("probeAnno.rda")
      
      if(!exists("xn1")) {
        load("seg-polyA-050525/xn.rda")
        xn1=xn
      }
      if(!exists("xn2")) {
        load("seg-tot-050525/xn.rda")
        xn2=xn
      }
      
      zz = cbind(rowMeans(exprs(xn1)), rowMeans(exprs(xn2)))
      start = c(113.5, 115.3)
      end   = c(113.8, 115.6)
      
      pushViewport(viewport(layout=grid.layout(2, 2)))
      for(i in 1:2)
        for(j in 1:2) {
          pushViewport(viewport(layout.pos.col=i, layout.pos.row=j))
          plotAlongChrom(2, coord = c(start[i], end[i])*1e3,
                         y = zz[,j], probeAnno = probeAnno,
                         gff = gff)
          popViewport()
        }
      popViewport()
      
    }
    
    ## heatmap plot
    if(what=="heatmap"){
      if(!exists("xn")) {
        load("/ebi/research/huber/Projects/tilingCycle/xn.rda")
        ex = exprs(xn)
        colnames(ex) = xn$SampleID
        time = as.numeric(colnames(ex))
        stopifnot(!any(is.na(time)))
        ex = ex[, order(time)]
      }
      if(!exists("probeAnno"))
        load("probeAnno.rda")
      
      smoothRank = function(y) {
        stopifnot(nrow(y)>=5)
        idx = 3:(nrow(y)-2)
        res = matrix(as.numeric(NA), nrow=nrow(y), ncol=ncol(y))
        res[idx, ] = y[idx,] + y[idx+1,] + y[idx+2,] + y[idx-1,] + y[idx-2,]
        return(rank(res) / length(res))
      }
      
      justRank = function(y) {
        return(rank(y) / length(y))
      }
      
      
      plotAlongChrom(y = ex, probeAnno = probeAnno, gff=gff,
                     what = "heatmap",
                     transformation = smoothRank,
                     chr= 1, coord = c(60, 66.5)*1e3)
      
    }
    if(dev %in% c("pdf", "png"))
      dev.off()
  } ## for    

@ 

\end{document}





          
