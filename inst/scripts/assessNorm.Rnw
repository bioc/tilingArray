%\VignetteIndexEntry{tilingArray - assess normalization}
%\VignetteDepends{tilingArray}
%\VignetteKeywords{normalization}
%\VignettePackage{tilingArray}

\documentclass[11pt]{article}
\usepackage{geometry}\usepackage{color}
\definecolor{darkblue}{rgb}{0.0,0.0,0.75}
\usepackage[%
baseurl={http://www.bioconductor.org},%
pdftitle={Assessing signal/noise ratio before and after normalization},%
pdfauthor={Wolfgang Huber},%
pdfsubject={tilingArray},%
pdfkeywords={Bioconductor},%
pagebackref,bookmarks,colorlinks,linkcolor=darkblue,citecolor=darkblue,%
pagecolor=darkblue,raiselinks,plainpages,pdftex]{hyperref}

%------------------------------------------------------------
% newcommand
%------------------------------------------------------------
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}
\newcommand{\mbs}[1]{{\mbox{\scriptsize #1}}}

\newcommand{\myincfig}[3]{%
  \begin{figure}[htbp]
    \begin{center}
      \includegraphics[width=#2]{#1}
      \caption{\label{#1}#3}
    \end{center}
  \end{figure}
}

\begin{document}

%------------------------------------------------------------
\title{Assessing signal/noise ratio before and after normalization}
%------------------------------------------------------------
\author{Wolfgang Huber}
\maketitle
\tableofcontents


\section{Introduction}
The purpose of this document is to assess the performance of the
probe-response normalization by the function
\Rfunction{normalizeByReference} in the \Rpackage{tilingArray}
package. We use the example data from the David et
al.~\cite{David2006} paper, which is provided in the
\Rpackage{davidTiling} package.
%
<<load, results=hide>>=
library("tilingArray")
library("davidTiling")
## if(!exists("davidTiling"))
data("davidTiling")
@ 
%
<<errorReporting, echo=FALSE>>=
options(error=recover, warn=2, digits=3)
@ 
%
It contains \Sexpr{nrow(pData(davidTiling))} arrays with
\Sexpr{nrow(exprs(davidTiling))} features each. Three of them were hybridized to
genomic DNA, which will use a reference for the normalization, and
five to RNA.
<<showDavidTilingData>>=
dim(exprs(davidTiling))
sampleNames(davidTiling)
@

%----------------------------------------
\section{PM and MM features}
First, we determine the indices of the PM and MM features. 
The array has 2560 rows and 2560 columns. If we count the 
rows and columns from 0 to 2559, then the indices of the features' intensities
in the expression matrix \Robject{exprs(davidTiling)} are given
by r*2560+c. The PM features 
lie in rows $1, 3, \ldots, 2557$, their corresponding MM features in rows
$2, 4, \ldots, 2558$:
<<PMandMM>>=
nc = as.integer(2560)
PMind = rep(seq(as.integer(1), nc-as.integer(3), by=as.integer(2)), each=nc)*nc + (1:nc)
MMind = PMind + nc
@ 
To verify this, let's look at the scatterplot of PM versus MM values
for the first chip, shown in Figure~\ref{assessNorm-viewPMandMMscp}:
%
<<viewPMandMMscp,fig=TRUE,include=FALSE,width=5,height=5,eps=FALSE>>=
x1 = log(exprs(davidTiling)[PMind, 1], 2)
x2 = log(exprs(davidTiling)[MMind, 1], 2)
smoothScatter(x1,x2,nrpoints=0,xlab="PM", ylab="MM")
abline(a=0,b=1,col="red")
@ 
\myincfig{assessNorm-viewPMandMMscp}{0.5\textwidth}{%
Scatterplot of M versus MM values
for the first chip in the \Robject{davidTiling} data.}

%----------------------------------------
\section{Background features}
For the background estimation, we need to specify a set of
``background'' features, that is features for which we expect no specific
signal. The feature information in the \Rpackage{davidTiling} package is
stored in the environment \Robject{probeAnno}. The following code selects 
all probe that do not map to a genomic feature (such as ORF, ncRNA) on 
either strand.
<<backgroundFeatures>>=
## if(!exists("probeAnno"))
data("probeAnno")
ispm = rep(FALSE, nc*nc)
ispm[PMind] = TRUE
isbg = (probeAnno$probeReverse$no_feature=="no" &
        probeAnno$probeDirect$no_feature=="no" &
        ispm)
@

%----------------------------------------
\section{Normalization}
<<normalizeByReference>>=
isRNA = davidTiling$nucleicAcid %in% c("poly(A) RNA","total RNA")
isDNA = davidTiling$nucleicAcid %in% "genomic DNA"
stopifnot(sum(isRNA)==5, sum(isDNA)==3)
## if(!exists("xn2"))
  xn2 = cache("xn2",
    normalizeByReference(davidTiling[,isRNA], davidTiling[,isDNA], 
                         pm=PMind, background=isbg,
                         plotFileNames=sprintf("assessNorm-normalize%d.pdf", seq(along=which(isRNA)))))
@
 
%----------------------------------------
\section{Alternative normalization methods}
\subsection{Without dropping the worst 5\% probes}
For comparison, we also compare to the situation in which 
we do not throw out the weakest features, by setting 
\Robject{cutoffQuantile=0}.
<<normalizeWithoutThrowout>>=
## if(!exists("xn1"))
  xn1 = cache("xn1",
    normalizeByReference(davidTiling[,isRNA], davidTiling[,isDNA], 
                         pm=PMind, background=isbg, cutoffQuantile=0))
@ 
%

\subsection{PM-MM}
<<PMMM>>=
z = exprs(davidTiling)[PMind, isRNA] - exprs(davidTiling)[MMind, isRNA] + 16
z[z<=0] = NA

xMM = matrix(as.numeric(NA), nrow=nc*nc, ncol=sum(isRNA))
xMM[PMind, ] = log2(z)
@ 

%----------------------------------------
\section{Assessment}
\subsection{Visually}

We would like to visualize the data along genomic coordinates. We
select the features that map to the longest chromosome, which is
chromosome 4. The integer vectors \Robject{sta} and \Robject{end} contain the start
and end coordinate of their match, \Robject{ind} their indices in the array
\Robject{exprs(davidTiling)}.
hit.
<<stainduni>>=
sta = probeAnno$"9.-.start"
end = probeAnno$"9.-.end"
ind = probeAnno$"9.-.index"
@ 
%
We construct a list of vectors, each containing different versions of
the intensity data, in order that corresponds to \Robject{sta} and
\Robject{ind} from above.
<<setUpDifferentNormMethods>>=
dat = vector(mode="list", length=5)
dat[[1]] = log2(exprs(davidTiling)[ind, which(isDNA)[1]])
dat[[2]] = log2(exprs(davidTiling)[ind, which(isRNA)[1]])
dat[[3]] = xMM[ind, 1]
dat[[4]] = dat[[2]]-dat[[1]]
dat[[5]] = exprs(xn1)[ind, 1]
dat[[6]] = exprs(xn2)[ind, 1]
for(j in 4:length(dat))
  dat[[j]] = dat[[j]] - quantile(dat[[j]], 0.05, na.rm=TRUE)
@ 
%
We select a 10kB region around the highly expressed genes RPN2 and SER33
to fit on a plot, and set the $y$-axis limits:
<<selectRegionForPlot>>=
sel = (sta>=216600 & end<=227000)
ysc = sapply(dat, function(py) quantile(py, probs=c(0, 0.99), na.rm=TRUE))
ysc[, 4] = ysc[, 5] = ysc[, 6]
@ 
%
Now we are ready to plot:
<<alongChromPlot, fig=TRUE, include=FALSE, height=10, width=8,eps=FALSE>>=
anno = data.frame(start=c(217860, 221078),
                  end  =c(220697, 222487),
                  name =I(c("RPN2", "SER33")))
ticks = c(217, 223, 224, 225, 226)
comparisonPlot((sta+end)[sel]/2, lapply(dat, "[", sel), yscale=ysc, anno=anno, ticks=ticks)
@ 
%
\myincfig{assessNorm-alongChromPlot}{0.8\textwidth}{% 
Scatterplot of different types of signal ($y$-axis) along genomic
coordinates ($x$-axis). Each dot corresponds to a microarray feature. 
a) signal from one of the DNA hybridizations (logarithmic scale, base 2).  
The $y$-coordinate of each dot is also encoded using
a pseudo-color scheme. Dark red corresponds to features that have a 
very weak response, dark blue to those with the strongest response.
The same coloring is also used in panels b)-f).
b) unnormalized intensities from one of the poly(A) RNA bybridizations
(logarithmic scale, base 2).  
c) $\log_2(\mbox{PM}-\mbox{MM}+16)$
d) Divide RNA-signal by DNA-signal then take logarithm (base 2). 
e) Background subtraction of the RNA-signal, divide by DNA-signal, then 
variance stabilizing normalization (vsn, glog base 2). 
f) In addition to d), drop the 5\% weakest features in the DNA hybridization. 
}

%----------------------------------------
\subsection{Quantitatively}
<<defineControls>>=

positiveCtrls = cbind(c(217860,220697), ## RPN2
                      c(221078,222487)) ## SER33 	.
negativeCtrls = cbind(c(216800, 217700),
                      c(222800, 227000)) ## SPO22

## controls on chromosome 4 + :
# sta = probeAnno$"4.+.start"
# end = probeAnno$"4.+.end"
# ind = probeAnno$"4.+.index"
# positiveCtrls = cbind(
#     c( 22823,  25876),  ## LRG1
#     c( 44066,  45907),  ## SSB1
#     c( 78427,  79059),  ## SHR3
#     c(116322, 116867)   ## ARF1
#     )
# negativeCtrls = cbind(
#     c( 26000,  30500), ## LRG1 ... YDL237W
#     c( 48000,  49800), ## SSB1 ... 
#     c(115989, 116133),  
#     c(121429, 121973),
#     c(114261, 114581) 
#     )
@ 
%
This function calculates number that quantify \emph{signal} and
\emph{noise}.  Noise is calculated as the weighted average of the
differences between 95\% and 5\% quantiles of the data within each of
the control regions.  Divide by
$Q_{0.95}^{\mbs{Norm}}-Q_{0.05}^{\mbs{Norm}}\approx 3.28$ so that it
corresponds to the standard deviation if the distribution were Normal.
%
<<defineWithinAndBetween>>=
fac = 2*qnorm(0.95)

withinAndBetween = function(x) {
  meanAndSd = function(region) {
    d = x[(sta>=region[1]) & (end<=region[2])]
    c(mean(d, na.rm=TRUE), 
      diff(quantile(d, c(0.05, 0.95), na.rm=TRUE))/fac, 
      sum(!is.na(d)))
  }
  p = apply(positiveCtrls, 2, meanAndSd)
  n = apply(negativeCtrls, 2, meanAndSd)
  wtav = function(q, i)
    sum(q[i,]*q[3,])/sum(q[3,])
  ## cat("p\n"); print(p); cat("n\n"); print(n)
  signal = sum(p[1,]*p[3,])/sum(p[3,]) - sum(n[1,]*n[3,])/sum(n[3,])
  noise  = (sum(p[2,]*p[3,])+sum(n[2,]*n[3,])) / (sum(p[3,])+sum(n[3,]))
  return(c("s/n"=signal/noise,s=signal,n=noise))
}
@ 
<<applyWithinAndBetween, print=TRUE>>=
sn = sapply(dat, withinAndBetween)

@ 


\begin{thebibliography}{10}

\bibitem{David2006}
Lior David, Wolfgang Huber, Marina Granovskaia, Joern Toedling, Curtis J. Palm, Lee Bofkin, Ted Jones,
Ronald W. Davis, and Lars M. Steinmetz
\newblock A high-resolution map of transcription in the
yeast genome.
\newblock \textit{PNAS}, 2006.

\end{thebibliography}

\end{document}
